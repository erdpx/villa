# C++ Cost Functions Reference

## ZCoordLoss (Lines 286-303)

```cpp
struct ZCoordLoss {
    ZCoordLoss(float z, float w) :  _z(z), _w(w) {};
    template <typename T>
    bool operator()(const T* const p, T* residual) const {
        residual[0] = T(_w)*(p[2] - T(_z));
        
        return true;
    }
    
    float _z;
    float _w;
    
    static ceres::CostFunction* Create(float z, float w = 1.0)
    {
        return new ceres::AutoDiffCostFunction<ZCoordLoss, 1, 3>(new ZCoordLoss(z, w));
    }
};
```

## LinChkDistLoss (Lines 257-284)

```cpp
struct LinChkDistLoss {
    LinChkDistLoss(const cv::Vec2d &p, float w) : _p(p), _w(w) {};
    template <typename T>
    bool operator()(const T* const p, T* residual) const {
        T a = abs(p[0]-T(_p[0]));
        T b = abs(p[1]-T(_p[1]));
        if (a > T(0))
            residual[0] = T(_w)*sqrt(a);
        else
            residual[0] = T(0);

        if (b > T(0))
            residual[1] = T(_w)*sqrt(b);
        else
            residual[1] = T(0);

        return true;
    }

    cv::Vec2d _p;
    float _w;

    static ceres::CostFunction* Create(const cv::Vec2d &p, float w = 1.0)
    {
        return new ceres::AutoDiffCostFunction<LinChkDistLoss, 2, 2>(new LinChkDistLoss(p, w));
    }
};
```

## ZLocationLoss (Lines 305-333)

```cpp
template <typename V>
struct ZLocationLoss {
    ZLocationLoss(const cv::Mat_<V> &m, float z, float w) :  _m(m), _z(z), _w(w) {};
    template <typename T>
    bool operator()(const T* const l, T* residual) const {
        T p[3];
        
        if (!loc_valid(_m, {val(l[0]), val(l[1])})) {
            residual[0] = T(0);
            return true;
        }
        
        interp_lin_2d(_m, l[0], l[1], p);
        
        residual[0] = T(_w)*(p[2] - T(_z));
        
        return true;
    }
    
    const cv::Mat_<V> _m;
    float _z;
    float _w;
    
    static ceres::CostFunction* Create(const cv::Mat_<V> &m, float z, float w = 1.0)
    {
        return new ceres::AutoDiffCostFunction<ZLocationLoss, 1, 2>(new ZLocationLoss(m, z, w));
    }
};
```

## SurfaceLossD (Lines 224-255)

```cpp
struct SurfaceLossD {
    //NOTE we expect loc to be [y, x]
    SurfaceLossD(const cv::Mat_<cv::Vec3f> &m, float w) : _m(m), _w(w) {};
    template <typename T>
    bool operator()(const T* const p, const T* const l, T* residual) const {
        T v[3];

        if (!loc_valid(_m, {val(l[0]), val(l[1])})) {
            residual[0] = T(0);
            residual[1] = T(0);
            residual[2] = T(0);
            return true;
        }

        interp_lin_2d(_m, l[0], l[1], v);

        residual[0] = T(_w)*(v[0] - p[0]);
        residual[1] = T(_w)*(v[1] - p[1]);
        residual[2] = T(_w)*(v[2] - p[2]);

        return true;
    }

    const cv::Mat_<cv::Vec3f> _m;
    float _w;

    static ceres::CostFunction* Create(const cv::Mat_<cv::Vec3f> &m, float w = 1.0)
    {
        return new ceres::AutoDiffCostFunction<SurfaceLossD, 3, 3, 2>(new SurfaceLossD(m, w));
    }
};
```

## SpaceLossAcc (Lines 335-357)

```cpp
template <typename T, typename C>
struct SpaceLossAcc {
    SpaceLossAcc(Chunked3d<T,C> &t, float w) : _interpolator(std::make_unique<CachedChunked3dInterpolator<T,C>>(t)), _w(w) {};
    template <typename E>
    bool operator()(const E* const l, E* residual) const {
        E v;

        _interpolator->template Evaluate<E>(l[2], l[1], l[0], &v);

        residual[0] = E(_w)*v;

        return true;
    }

    float _w;
    std::unique_ptr<CachedChunked3dInterpolator<T,C>> _interpolator;

    static ceres::CostFunction* Create(Chunked3d<T,C> &t, float w = 1.0)
    {
        return new ceres::AutoDiffCostFunction<SpaceLossAcc<T,C>, 1, 3>(new SpaceLossAcc<T,C>(t, w));
    }
};
```

## AnchorLoss (Lines 359-390)

```cpp
template <typename E, typename C>
struct AnchorLoss {
    AnchorLoss(Chunked3d<E,C> &t, float w) : _interp(new CachedChunked3dInterpolator<E,C>(t)), _w(w) {};
    template <typename T>
    bool operator()(const T* const p, const T* const anchor, T* residual) const {
        T v;
        T sum = T(0);

        _interp->template Evaluate<T>(anchor[0], anchor[1], anchor[2], &v);

        T d[3] = {p[0]-anchor[0], p[1]-anchor[1], p[2]-anchor[2]};

        v = v - T(1);

        if (v < T(0))
            v = T(0);

        residual[0] = T(_w)*v*v;
        residual[1] = T(_w)*sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);

        return true;
    }

    std::unique_ptr<CachedChunked3dInterpolator<E,C>> _interp;
    float _w;

    static ceres::CostFunction* Create(Chunked3d<E,C> &t, float w = 1.0)
    {
        return new ceres::AutoDiffCostFunction<AnchorLoss, 2, 3, 3>(new AnchorLoss({t, w}));
    }
};
```

## SpaceLineLossAcc (Lines 392-428)

```cpp
template <typename T, typename C>
struct SpaceLineLossAcc {
    SpaceLineLossAcc(Chunked3d<T,C> &t, int steps, float w) : _steps(steps), _w(w)
    {
        _interpolator.resize(_steps-1);
        for(int i=1;i<_steps;i++)
            _interpolator[i-1].reset(new CachedChunked3dInterpolator<T,C>(t));
    };
    template <typename E>
    bool operator()(const E* const la, const E* const lb, E* residual) const {
        E v;
        E sum = E(0);

        bool ign = false;

        for(int i=1;i<_steps;i++) {
            E f2 = E(float(i)/_steps);
            E f1 = E(1.0f-float(i)/_steps);
            _interpolator[i-1].get()->template Evaluate<E>(f1*la[2]+f2*lb[2], f1*la[1]+f2*lb[1], f1*la[0]+f2*lb[0], &v);
            sum += E(_w)*v;
        }

        residual[0] = sum/E(_steps-1);

        return true;
    }

    std::vector<std::unique_ptr<CachedChunked3dInterpolator<T,C>>> _interpolator;
    int _steps;
    float _w;

    static ceres::CostFunction* Create(Chunked3d<T,C> &t, int steps, float w = 1.0)
    {
        return new ceres::AutoDiffCostFunction<SpaceLineLossAcc, 1, 3, 3>(new SpaceLineLossAcc(t, steps, w));
    }
};
```